"""
simulators.py

Parse read files generated by simulators and annotate them with information
about their point/configuration of origin.

Better if we can do everything we need just given the read name.
"""

import re

def sameAlignment(al, left, right, refid, fw, wiggle=10):
    # TODO: calculate reference length, e.g. by parsing CIGAR
    return refid == al.refid and \
           abs(left - al.pos) < wiggle and \
           abs(right - (al.pos + len(al))) < wiggle and \
           al.fw == fw

_mason_orig_beg = re.compile('orig_begin=([0-9]*)')
_mason_orig_end = re.compile('orig_end=([0-9]*)')
_mason_contig = re.compile('contig=([^\s]*)')
_mason_strand = re.compile('strand=([^\s]*)')

def parseMason(nm):
    be = _mason_orig_beg.search(nm)
    en = _mason_orig_end.search(nm)
    assert be is not None and en is not None
    
    # Mason's offsets are 0-based
    left, right = int(be.group(1)), int(en.group(1))
    
    rr = _mason_contig.search(nm)
    assert rr is not None
    refid = rr.group(1)
    
    sr = _mason_strand.search(nm)
    assert sr is not None
    strand = sr.group(1)
    
    return left, right, refid, strand == 'forward'

def alignmentCorrectMason(al, wiggle=10):
    left, right, refid, fw = parseMason(al.name)
    return sameAlignment(al, left, right, refid, fw, wiggle)

def parseWgsim(nm):
    raise RuntimeException('Not implemented')

def alignmentCorrectWgsim(al, wiggle=10):
    left, right, refid, fw = parseWgsim(al.name)
    return sameAlignment(al, left, right, refid, fw, wiggle)

def parseGrinder(nm):
    raise RuntimeException('Not implemented')

def alignmentCorrectGrinder(al, wiggle=10):
    left, right, refid, fw = parseGrinder(al.name)
    return sameAlignment(al, left, right, refid, fw, wiggle)

def parseSimulatedReadName(nm, format='mason'):
    if format == 'mason': return parseMason(nm)
    elif format == 'wgsim': return parseWgsim(nm)
    elif format == 'grinder': return parseGrinder(nm)
    else: raise RuntimeException('Bad format: "%s"' % format)
