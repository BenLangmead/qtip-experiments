#!/usr/bin/env python

"""
summ_errs.py

Summarize the alignment errors.  Assumes (1) all the reads are generated by
Mason, and that the big long read name was faithfully preserved (i.e. with
bowtie2's --sam-no-qname-trunc).

Author: Ben Langmead
Date: 7/3/2013
Contact: langmea@cs.jhu.edu
"""

import string
import re
import argparse
    
parser = argparse.ArgumentParser(description='Sample FASTQ reads from file')
parser.add_argument('--in', dest='input', metavar='path', type=str, nargs='+',
                    required=True, help='FASTQ file input.')
parser.add_argument('--out', metavar='path', type=str, required=False, help='Output.')
parser.add_argument('--wiggle', metavar='integer', type=int, required=False, default=50,
                    help='Wiggle-room to allow for correctness check')
args = parser.parse_args()

onre = re.compile(' contig=([^\s]+)')
obre = re.compile(' orig_begin=([0-9]+)')
oere = re.compile(' orig_end=([0-9]+)')
oore = re.compile(' strand=([a-z]+)')

good_refs = set()
contamination_refs = set()
err1, err2, err3 = 0, 0, 0
err1_map = {}

for ifn in args.input:
    with open(ifn, 'r') as ifh:
        for ln in ifh:
            if ln[0] == '@':
                # Parse reference sequences aligned to
                fl, v1, _ = string.split(ln, '\t', 2)
                if fl == "@SQ":
                    good_refs.add(v1[3:])  # clip off SN:
                continue
            
            name, flags, refid, refoff, mapq, cigar, tmp1, tmp2, tmp3, seq, _ = string.split(ln, '\t', 10)
            flags, refoff = int(flags), int(refoff)
            seqlen = len(seq)
            
            # Get simulated start, end from name
            sim_refid = onre.search(ln)
            assert sim_refid is not None
            sim_refid = sim_refid.group(1)
            assert sim_refid is not None
            
            sim_st = obre.search(ln)
            assert sim_st is not None
            sim_st = sim_st.group(1)
            assert sim_st is not None
            
            sim_en = oere.search(ln)
            assert sim_en is not None
            sim_en = sim_en.group(1)
            assert sim_en is not None
            
            sim_o = oore.search(ln)
            assert sim_o is not None
            sim_o = sim_o.group(1)
            assert sim_o is not None
            
            sim_st, sim_en = int(sim_st), int(sim_en)
            
            if sim_refid not in good_refs:
                contamination_refs.add(sim_refid)
            
            if (flags & 4) != 0:
                # failed to align
                if sim_refid in good_refs:
                    err2 += 1  # category-2 error
            else:
                if sim_refid not in good_refs:
                    err1_map[sim_refid] = err1_map.get(sim_refid, 0) + 1
                    err1 += 1  # category-1 error
                else:
                    # Right ref seq?
                    same = False
                    if refid == sim_refid:
                        # Right orientation?
                        fw = (flags & 16) == 0
                        if fw == (sim_o == "forward"):
                            st, en = refoff, refoff + seqlen
                            if abs(st - sim_st) < args.wiggle and \
                               abs(en - sim_en) < args.wiggle:
                                same = True
                    if not same:
                        err3 += 1

print "Good refs:"
print ' '.join(good_refs)

print "Contamination refs:"
print ' '.join(contamination_refs)

errtot = err1 + err2 + err3
if errtot == 0:
    print "No errors"
else:
    print "Category-1 errors: %d (%0.3f%%)" % (err1, 100.0 * err1 / errtot)
    print "Category-2 errors: %d (%0.3f%%)" % (err2, 100.0 * err2 / errtot)
    print "Category-3 errors: %d (%0.3f%%)" % (err3, 100.0 * err3 / errtot)
    
    print "Category-1 error breakdown"
    for k, v in err1_map.iteritems():
        print "  %s: %d" % (k, v)
