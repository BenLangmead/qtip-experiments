diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_bt.cpp bowtie2-mapq/aligner_bt.cpp
--- bowtie2-v2.2.9.orig/aligner_bt.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_bt.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -1595,13 +1595,15 @@ int BtBranchTracer::trySolution(
 		return BT_REJECTED_CORE_DIAG;
 	}
 	off = br->leftmostCol();
+	size_t trimBeg = br->uppermostRow();
+	size_t trimEnd = prob_.qrylen_ - prob_.row_ - 1;
 	score.score_ = prob_.targ_;
+	score.basesAligned_ = (int)(prob_.qrylen_ - trimBeg - trimEnd - ned.size());
+	score.edits_ = (int)ned.size();
 	score.ns_    = ns;
 	score.gaps_  = ngap;
 	res.alres.setScore(score);
 	res.alres.setRefNs(nrefns);
-	size_t trimBeg = br->uppermostRow();
-	size_t trimEnd = prob_.qrylen_ - prob_.row_ - 1;
 	assert_leq(trimBeg, prob_.qrylen_);
 	assert_leq(trimEnd, prob_.qrylen_);
 	TRefOff refoff = off + prob_.refoff_ + prob_.rect_->refl;
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_result.cpp bowtie2-mapq/aligner_result.cpp
--- bowtie2-v2.2.9.orig/aligner_result.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_result.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -1050,11 +1050,15 @@ void AlnSetSumm::init(
 {
 	assert(rd1 != NULL || rd2 != NULL);
 	assert((rs1 == NULL) == (rs2 == NULL));
-	AlnScore best[2], secbest[2], bestPaired, secbestPaired;
+//	AlnScore secbest[2], secbestPaired;
+	AlnScore best[2], bestPaired;
 	size_t szs[2];
-	best[0].invalidate();    secbest[0].invalidate();
-	best[1].invalidate();    secbest[1].invalidate();
-	bestPaired.invalidate(); secbestPaired.invalidate();
+	best[0].invalidate();
+	best[1].invalidate();
+//	secbest[0].invalidate();
+//	secbest[1].invalidate();
+	bestPaired.invalidate();
+//	secbestPaired.invalidate();
 	bool paired = (rs1 != NULL && rs2 != NULL);
 	szs[0] = szs[1] = 0;
 	// Set bestPaired and secbestPaired
@@ -1063,20 +1067,20 @@ void AlnSetSumm::init(
 		assert_eq(rs1->size(), rs2->size());
 		szs[0] = szs[1] = rs1->size();
 		assert_gt(szs[0], 0);
-		for(size_t i = 0; i < rs1->size(); i++) {
-			// Combine mate scores into a concordant alignment score by
-			// summing them
-			AlnScore sc = (*rs1)[i].score() + (*rs2)[i].score();
-			if(sc > bestPaired) {
-				secbestPaired = bestPaired;
-				bestPaired = sc;
-				assert(VALID_AL_SCORE(bestPaired));
-			} else if(sc > secbestPaired) {
-				secbestPaired = sc;
-				assert(VALID_AL_SCORE(bestPaired));
-				assert(VALID_AL_SCORE(secbestPaired));
-			}
-		}
+//		for(size_t i = 0; i < rs1->size(); i++) {
+//			// Combine mate scores into a concordant alignment score by
+//			// summing them
+//			AlnScore sc = (*rs1)[i].score() + (*rs2)[i].score();
+//			if(sc > bestPaired) {
+//				secbestPaired = bestPaired;
+//				bestPaired = sc;
+//				assert(VALID_AL_SCORE(bestPaired));
+//			} else if(sc > secbestPaired) {
+//				secbestPaired = sc;
+//				assert(VALID_AL_SCORE(bestPaired));
+//				assert(VALID_AL_SCORE(secbestPaired));
+//			}
+//		}
 	}
 	// Set best[] and secbest[]
 	for(int j = 0; j < 2; j++) {
@@ -1085,27 +1089,21 @@ void AlnSetSumm::init(
 			continue;
 		}
 		szs[j] = rs->size();
-		for(size_t i = 0; i < rs->size(); i++) {
-			AlnScore sc = (*rs)[i].score();
-			if(sc > best[j]) {
-				secbest[j] = best[j];
-				best[j] = sc;
-				assert(VALID_AL_SCORE(best[j]));
-			} else if(sc > secbest[j]) {
-				secbest[j] = sc;
-				assert(VALID_AL_SCORE(best[j]));
-				assert(VALID_AL_SCORE(secbest[j]));
-			}
-		}
+//		for(size_t i = 0; i < rs->size(); i++) {
+//			AlnScore sc = (*rs)[i].score();
+//			if(sc > best[j]) {
+//				secbest[j] = best[j];
+//				best[j] = sc;
+//				assert(VALID_AL_SCORE(best[j]));
+//			} else if(sc > secbest[j]) {
+//				secbest[j] = sc;
+//				assert(VALID_AL_SCORE(best[j]));
+//				assert(VALID_AL_SCORE(secbest[j]));
+//			}
+//		}
 	}
 	if(szs[0] > 0 || szs[1] > 0) {
 		init(
-			best[0],
-			secbest[0],
-			best[1],
-			secbest[1],
-			bestPaired,
-			secbestPaired,
 			(szs[0] == 0) ? 0 : (szs[0] - 1),
 			(szs[1] == 0) ? 0 : (szs[1] - 1),
 			paired,
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_result.h bowtie2-mapq/aligner_result.h
--- bowtie2-v2.2.9.orig/aligner_result.h	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_result.h	2016-10-10 23:07:32.000000000 -0400
@@ -63,8 +63,10 @@ public:
 	/**
 	 * Gapped scores are invalid until proven valid.
 	 */
-	inline AlnScore(TAlScore score, TAlScore ns, TAlScore gaps) {
+	inline AlnScore(TAlScore score, int basesAligned, int edits, TAlScore ns, TAlScore gaps) {
 		score_ = score;
+		basesAligned_ = basesAligned;
+		edits_ = edits;
 		ns_ = ns;
 		gaps_ = gaps;
 		assert(valid());
@@ -74,7 +76,7 @@ public:
 	 * Reset the score.
 	 */
 	void reset() {
-		score_ = ns_ = gaps_ = 0;
+		score_ = basesAligned_ = edits_ = ns_ = gaps_ = 0;
 	}
 
 	/**
@@ -99,6 +101,8 @@ public:
 	 */
 	inline void invalidate() {
 		score_ = MIN_I64;
+		edits_ = basesAligned_ = std::numeric_limits<int>::min();
+		ns_ = gaps_ = 0;
 		assert(!valid());
 	}
 	
@@ -139,7 +143,9 @@ public:
 	inline AlnScore& operator=(const AlnScore& o) {
 		// Profiling shows many cache misses on following lines
 		gaps_  = o.gaps_;
+		basesAligned_ = o.basesAligned_;
 		ns_    = o.ns_;
+		edits_ = o.edits_;
 		score_ = o.score_;
 		assert_lt(ns_, 0x7fffffff);
 		return *this;
@@ -187,33 +193,15 @@ public:
 	}
 
 	/**
-	 * Return true iff this score is <= score o.
-	 */
-	inline bool operator<=(const AlnScore& o) const {
-		return !operator>(o);
-	}
-
-	/**
-	 * Calculate difference between two SwScores.
-	 */
-	inline AlnScore operator-(const AlnScore& o) const {
-		if(!VALID_AL_SCORE(*this)) return *this;
-		AlnScore s; 
-		s.gaps_ = gaps_ - o.gaps_;
-		s.ns_ = ns_;
-		s.score_ = score_ - o.score_;
-		assert_lt(s.ns_, 0x7fffffff);
-		return s;
-	}
-
-	/**
 	 * Calculate sum of two SwScores.
 	 */
 	inline AlnScore operator+(const AlnScore& o) const {
 		if(!VALID_AL_SCORE(*this)) return *this;
 		AlnScore s;
 		s.gaps_ = gaps_ + o.gaps_;
-		s.ns_ = ns_;
+		s.basesAligned_ = basesAligned_ + o.basesAligned_;
+		s.ns_ = ns_ + o.ns_;
+		s.edits_ = edits_ + o.edits_;
 		s.score_ = score_ + o.score_;
 		assert_lt(s.ns_, 0x7fffffff);
 		return s;
@@ -225,50 +213,30 @@ public:
 	inline AlnScore operator+=(const AlnScore& o) {
 		if(VALID_AL_SCORE(*this)) {
 			gaps_ += o.gaps_;
+			basesAligned_ += o.basesAligned_;
 			score_ += o.score_;
+			edits_ += o.edits_;
+			ns_ += o.ns_;
 		}
 		return (*this);
 	}
 
-	/**
-	 * Subtract given SwScore from this one.
-	 */
-	inline AlnScore operator-=(const AlnScore& o) {
-		if(VALID_AL_SCORE(*this)) {
-			gaps_ -= o.gaps_;
-			score_ -= o.score_;
-		}
-		return (*this);
-	}
-
-	/**
-	 * Calculate difference between two SwScores.
-	 */
-	inline AlnScore operator-(int o) const {
-		return (*this) + -o;
-	}
-
-	/**
-	 * Calculate sum of a SwScore and an integer.
-	 */
-	inline AlnScore operator+(int o) const {
-		if(!VALID_AL_SCORE(*this)) return *this;
-		AlnScore s;
-		s.gaps_ = gaps_;
-		s.ns_ = ns_;
-		s.score_ = score_ + o;
-		assert_lt(s.ns_, 0x7fffffff);
-		return s;
-	}
-
 	TAlScore score()   const { return  score_; }
 	TAlScore penalty() const { return -score_; }
 	TAlScore gaps()    const { return  gaps_;  }
 	TAlScore ns()      const { return  ns_;    }
+	int basesAligned() const { return  basesAligned_; }
+	int nedit()        const { return  edits_; }
 
 	// Score accumulated so far (penalties are subtracted starting at 0)
 	TAlScore score_;
 	
+	// Number of bases matching between the read and reference
+	int basesAligned_;
+	
+	// Edit distance
+	int edits_;
+	
 	// Ns accumulated so far.  An N opposite a non-gap counts as 1 N
 	// (even if it's N-to-N)
 	TAlScore ns_;
@@ -904,7 +872,7 @@ public:
 		trim_st += (fw() ? pretrim5p_ : pretrim3p_);
 		trim_en += (fw() ? pretrim3p_ : pretrim5p_);
 		st.adjustOff(-trim_st);
-		en.adjustOff( trim_st);
+		en.adjustOff( trim_en);
 	}
 	
 	/**
@@ -1708,12 +1676,6 @@ public:
 	}
 
 	explicit AlnSetSumm(
-		AlnScore best1,
-		AlnScore secbest1,
-		AlnScore best2,
-		AlnScore secbest2,
-		AlnScore bestPaired,
-		AlnScore secbestPaired,
 		TNumAlns other1,
 		TNumAlns other2,
 		bool     paired,
@@ -1723,12 +1685,6 @@ public:
 		TRefOff  orefoff)
 	{
 		init(
-			best1,
-			secbest1,
-			best2,
-			secbest2,
-			bestPaired,
-			secbestPaired,
 			other1,
 			other2,
 			paired,
@@ -1742,12 +1698,22 @@ public:
 	 * Set to uninitialized state.
 	 */
 	void reset() {
-		best1_.invalidate();
-		secbest1_.invalidate();
-		best2_.invalidate();
-		secbest2_.invalidate();
-		bestPaired_.invalidate();
-		secbestPaired_.invalidate();
+		bestUScore_.invalidate();
+		bestP1Score_.invalidate();
+		bestP2Score_.invalidate();
+		bestCScore_.invalidate();
+		bestUDist_.invalidate();
+		bestP1Dist_.invalidate();
+		bestP2Dist_.invalidate();
+		bestCDist_.invalidate();
+		bestUnchosenUScore_.invalidate();
+		bestUnchosenP1Score_.invalidate();
+		bestUnchosenP2Score_.invalidate();
+		bestUnchosenCScore_.invalidate();
+		bestUnchosenUDist_.invalidate();
+		bestUnchosenP1Dist_.invalidate();
+		bestUnchosenP2Dist_.invalidate();
+		bestUnchosenCDist_.invalidate();
 		other1_ = other2_ = 0;
 		paired_ = false;
 		exhausted1_ = exhausted2_ = false;
@@ -1771,12 +1737,6 @@ public:
 	 * Initialize given fields.  See constructor for how fields are set.
 	 */
 	void init(
-		AlnScore best1,
-		AlnScore secbest1,
-		AlnScore best2,
-		AlnScore secbest2,
-		AlnScore bestPaired,
-		AlnScore secbestPaired,
 		TNumAlns other1,
 		TNumAlns other2,
 		bool     paired,
@@ -1785,12 +1745,6 @@ public:
 		TRefId   orefid,
 		TRefOff  orefoff)
 	{
-		best1_         = best1;
-		secbest1_      = secbest1;
-		best2_         = best2;
-		secbest2_      = secbest2;
-		bestPaired_    = bestPaired;
-		secbestPaired_ = secbestPaired;
 		other1_        = other1;
 		other2_        = other2;
 		paired_        = paired;
@@ -1806,7 +1760,7 @@ public:
 	 */
 	bool empty() const {
 		assert(repOk());
-		return !VALID_AL_SCORE(best1_);
+		return !VALID_AL_SCORE(bestScore(true));
 	}
 	
 #ifndef NDEBUG
@@ -1814,20 +1768,10 @@ public:
 	 * Check that the summary is internally consistent.
 	 */
 	bool repOk() const {
-		assert(other1_ == 0 ||  VALID_AL_SCORE(secbest1_));
-		assert(other1_ != 0 || !VALID_AL_SCORE(secbest1_));
-		assert(other2_ == 0 ||  VALID_AL_SCORE(secbest2_));
-		assert(other2_ != 0 || !VALID_AL_SCORE(secbest2_));
 		return true;
 	}
 #endif
 	
-	AlnScore best1()         const { return best1_;         }
-	AlnScore secbest1()      const { return secbest1_;      }
-	AlnScore best2()         const { return best2_;         }
-	AlnScore secbest2()      const { return secbest2_;      }
-	AlnScore bestPaired()    const { return bestPaired_;    }
-	AlnScore secbestPaired() const { return secbestPaired_; }
 	TNumAlns other1()        const { return other1_;        }
 	TNumAlns other2()        const { return other2_;        }
 	bool     paired()        const { return paired_;        }
@@ -1835,15 +1779,63 @@ public:
 	bool     exhausted2()    const { return exhausted2_;    }
 	TRefId   orefid()        const { return orefid_;        }
 	TRefOff  orefoff()       const { return orefoff_;       }
-	AlnScore bestUnchosen1() const { return bestUnchosen1_; }
-	AlnScore bestUnchosen2() const { return bestUnchosen2_; }
-	AlnScore bestUnchosenC() const { return bestUnchosenC_; }
+	
+	AlnScore bestUScore()  const { return bestUScore_;  }
+	AlnScore bestP1Score() const { return bestP1Score_; }
+	AlnScore bestP2Score() const { return bestP2Score_; }
+	AlnScore bestCScore()  const { return bestCScore_;  }
+	AlnScore bestUDist()   const { return bestUDist_;  }
+	AlnScore bestP1Dist()  const { return bestP1Dist_; }
+	AlnScore bestP2Dist()  const { return bestP2Dist_; }
+	AlnScore bestCDist()   const { return bestCDist_;  }
+
+	AlnScore bestUnchosenUScore()  const { return bestUnchosenUScore_;  }
+	AlnScore bestUnchosenP1Score() const { return bestUnchosenP1Score_; }
+	AlnScore bestUnchosenP2Score() const { return bestUnchosenP2Score_; }
+	AlnScore bestUnchosenCScore()  const { return bestUnchosenCScore_;  }
+	AlnScore bestUnchosenUDist()   const { return bestUnchosenUDist_;  }
+	AlnScore bestUnchosenP1Dist()  const { return bestUnchosenP1Dist_; }
+	AlnScore bestUnchosenP2Dist()  const { return bestUnchosenP2Dist_; }
+	AlnScore bestUnchosenCDist()   const { return bestUnchosenCDist_;  }
 
 	/**
-	 * Return best alignment score for 
+	 * Return best unchosen alignment score for end 1 or 2 of a pair.
 	 */
-	AlnScore bestUnchosen(bool mate1) const {
-		return mate1 ? bestUnchosen1_ : bestUnchosen2_;
+	AlnScore bestUnchosenPScore(bool mate1) const {
+		return mate1 ? bestUnchosenP1Score_ : bestUnchosenP2Score_;
+	}
+
+	/**
+	 * Return best unchosen edit distance for end 1 or 2 of a pair.
+	 */
+	AlnScore bestUnchosenPDist(bool mate1) const {
+		return mate1 ? bestUnchosenP1Dist_ : bestUnchosenP2Dist_;
+	}
+	
+	/**
+	 * Return best unchosen alignment score for end 1 or 2 whether
+	 * the read is a pair or not.
+	 */
+	AlnScore bestUnchosenScore(bool mate1) const {
+		if(mate1) {
+			return paired_ ? bestUnchosenP1Score_ : bestUnchosenUScore();
+		} else {
+			assert(paired_);
+			return bestUnchosenP2Score_;
+		}
+	}
+
+	/**
+	 * Return best unchosen edit distance for end 1 or 2 whether
+	 * the read is a pair or not.
+	 */
+	AlnScore bestUnchosenDist(bool mate1) const {
+		if(mate1) {
+			return paired_ ? bestUnchosenP1Dist_ : bestUnchosenUDist();
+		} else {
+			assert(paired_);
+			return bestUnchosenP2Dist_;
+		}
 	}
 
 	bool exhausted(bool mate1) const {
@@ -1851,47 +1843,86 @@ public:
 	}
 	
 	/**
-	 * Return best alignment score for mate 1 or mate 2, depending on argument.
+	 * Return best alignment score for end 1 or 2 whether the read is
+	 * a pair or not.
 	 */
-	AlnScore best(bool mate1) const {
-		return mate1 ? best1_ : best2_;
+	AlnScore bestScore(bool mate1) const {
+		if(mate1) {
+			return paired_ ? bestP1Score_ : bestUScore_;
+		} else {
+			assert(paired_);
+			return bestP2Score_;
+		}
 	}
-	
+
 	/**
-	 * Return the second-best score for the specified mate.  If the alignment
-	 * is paired and the specified mate aligns uniquely, return an invalid
-	 * second-best score.  This allows us to treat mates separately, so that
-	 * repetitive paired-end alignments don't trump potentially unique unpaired
-	 * alignments.
+	 * Return best edit distance for end 1 or 2 whether the read is
+	 * a pair or not.
 	 */
-	AlnScore secbest(bool mate1) const {
-		return mate1 ? secbest1_ : secbest2_;
+	AlnScore bestDist(bool mate1) const {
+		if(mate1) {
+			return paired_ ? bestP1Dist_ : bestUDist_;
+		} else {
+			assert(paired_);
+			return bestP2Dist_;
+		}
 	}
 	
 	/**
 	 * Add information about unchosen alignments to the summary.  This is
-	 * helpful for concordant alignments; when calculating mapping quality,
-	 * we might like to know about how good the unchosen mate and pair
-	 * alignments were.
-	 */
-	void setUnchosen(
-		AlnScore bestUnchosen1,
-		AlnScore bestUnchosen2,
-		AlnScore bestUnchosenC)
+	 * in its own "setter" function because it's not known until we've
+	 * picked which alignment to report, which is after we've initially
+	 * constructed the summary.
+	 *
+	 * Info about unchosen alignments is used for predicting mapping
+	 * quality.
+	 */
+	void setBest(
+		AlnScore bestUScore,
+		AlnScore bestUDist,
+		AlnScore bestP1Score,
+		AlnScore bestP1Dist,
+		AlnScore bestP2Score,
+		AlnScore bestP2Dist,
+		AlnScore bestCScore,
+		AlnScore bestCDist,
+		AlnScore bestUnchosenUScore,
+		AlnScore bestUnchosenUDist,
+		AlnScore bestUnchosenP1Score,
+		AlnScore bestUnchosenP1Dist,
+		AlnScore bestUnchosenP2Score,
+		AlnScore bestUnchosenP2Dist,
+		AlnScore bestUnchosenCScore,
+		AlnScore bestUnchosenCDist)
 	{
-		bestUnchosen1_ = bestUnchosen1;
-		bestUnchosen2_ = bestUnchosen2;
-		bestUnchosenC_ = bestUnchosenC;
+		assert(bestUScore.valid() == bestUDist.valid());
+		assert(bestP1Score.valid() == bestP1Dist.valid());
+		assert(bestP2Score.valid() == bestP2Dist.valid());
+		assert(bestCScore.valid() == bestCDist.valid());
+		assert(bestUnchosenUScore.valid() == bestUnchosenUDist.valid());
+		assert(bestUnchosenP1Score.valid() == bestUnchosenP1Dist.valid());
+		assert(bestUnchosenP2Score.valid() == bestUnchosenP2Dist.valid());
+		assert(bestUnchosenCScore.valid() == bestUnchosenCDist.valid());
+		bestUScore_ = bestUScore;
+		bestUDist_ = bestUDist;
+		bestP1Score_ = bestP1Score;
+		bestP1Dist_ = bestP1Dist;
+		bestP2Score_ = bestP2Score;
+		bestP2Dist_ = bestP2Dist;
+		bestCScore_ = bestCScore;
+		bestCDist_ = bestCDist;
+		bestUnchosenUScore_ = bestUnchosenUScore;
+		bestUnchosenUDist_ = bestUnchosenUDist;
+		bestUnchosenP1Score_ = bestUnchosenP1Score;
+		bestUnchosenP1Dist_ = bestUnchosenP1Dist;
+		bestUnchosenP2Score_ = bestUnchosenP2Score;
+		bestUnchosenP2Dist_ = bestUnchosenP2Dist;
+		bestUnchosenCScore_ = bestUnchosenCScore;
+		bestUnchosenCDist_ = bestUnchosenCDist;
 	}
 	
 protected:
 	
-	AlnScore bestPaired_;    // best full-alignment score found for this read
-	AlnScore secbestPaired_; // second-best
-	AlnScore best1_;         // best full-alignment score found for this read
-	AlnScore secbest1_;      // second-best
-	AlnScore best2_;         // best full-alignment score found for this read
-	AlnScore secbest2_;      // second-best
 	TNumAlns other1_;        // # more alignments within N points of second-best
 	TNumAlns other2_;        // # more alignments within N points of second-best
 	bool     paired_;        // results are paired
@@ -1900,9 +1931,23 @@ protected:
 	TRefId   orefid_;
 	TRefOff  orefoff_;
 
-	AlnScore bestUnchosen1_;
-	AlnScore bestUnchosen2_;
-	AlnScore bestUnchosenC_;
+	AlnScore bestUScore_;
+	AlnScore bestUDist_;
+	AlnScore bestP1Score_;
+	AlnScore bestP1Dist_;
+	AlnScore bestP2Score_;
+	AlnScore bestP2Dist_;
+	AlnScore bestCScore_;
+	AlnScore bestCDist_;
+
+	AlnScore bestUnchosenUScore_;
+	AlnScore bestUnchosenUDist_;
+	AlnScore bestUnchosenP1Score_;
+	AlnScore bestUnchosenP1Dist_;
+	AlnScore bestUnchosenP2Score_;
+	AlnScore bestUnchosenP2Dist_;
+	AlnScore bestUnchosenCScore_;
+	AlnScore bestUnchosenCDist_;
 };
 
 #endif
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_seed.cpp bowtie2-mapq/aligner_seed.cpp
--- bowtie2-v2.2.9.orig/aligner_seed.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_seed.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -379,7 +379,9 @@ pair<int, int> SeedAligner::instantiateS
 	bool norc,                 // don't align revcomp read
 	AlignmentCacheIface& cache,// holds some seed hits from previous reads
 	SeedResults& sr,           // holds all the seed hits
-	SeedSearchMetrics& met)    // metrics
+	SeedSearchMetrics& met,    // metrics
+	pair<int, int>& instFw,
+	pair<int, int>& instRc)
 {
 	assert(!seeds.empty());
 	assert_gt(read.length(), 0);
@@ -445,6 +447,7 @@ pair<int, int> SeedAligner::instantiateS
 				{
 					// Can we fill this seed hit in from the cache?
 					ret.first++;
+					if(fwi == 0) { instFw.first++; } else { instRc.first++; }
 				} else {
 					// Seed may fail to instantiate if there are Ns
 					// that prevent it from matching
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_seed.h bowtie2-mapq/aligner_seed.h
--- bowtie2-v2.2.9.orig/aligner_seed.h	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_seed.h	2016-10-10 23:07:32.000000000 -0400
@@ -670,10 +670,12 @@ public:
 		numRanges_ += qv.numRanges();
 		if(qv.numRanges() > 0) {
 			nonzTot_++;
-			if(qv.numRanges() == 1 and qv.numElts() == 1) {
+			if(qv.numRanges() == 1 && qv.numElts() == 1) {
 				uniTot_++;
+				uniTotS_[seedFw ? 0 : 1]++;
 			} else {
 				repTot_++;
+				repTotS_[seedFw ? 0 : 1]++;
 			}
 		}
 		assert(repOk(&ac));
@@ -729,8 +731,8 @@ public:
 		seqFw_.clear();
 		seqRc_.clear();
 		nonzTot_ = 0;
-		uniTot_ = 0;
-		repTot_ = 0;
+		uniTot_ = uniTotS_[0] = uniTotS_[1] = 0;
+		repTot_ = repTotS_[0] = repTotS_[1] = 0;
 		nonzFw_ = 0;
 		nonzRc_ = 0;
 		numOffs_ = 0;
@@ -827,11 +829,25 @@ public:
 	}
 
 	/**
-	 * Return fraction of seeds that align repetitively.
+	 * Return fraction of seeds that aligned uniquely on the given strand.
+	 */
+	size_t numUniqueSeedsStrand(bool fw) const {
+		return uniTotS_[fw ? 0 : 1];
+	}
+
+	/**
+	 * Return fraction of seeds that align repetitively on the given strand.
 	 */
 	size_t numRepeatSeeds() const {
 		return repTot_;
 	}
+
+	/**
+	 * Return fraction of seeds that align repetitively.
+	 */
+	size_t numRepeatSeedsStrand(bool fw) const {
+		return repTotS_[fw ? 0 : 1];
+	}
 	
 	/**
 	 * Return median of all the non-zero per-seed # hits
@@ -1329,7 +1345,9 @@ protected:
 	EList<bool>         sortedRc_;    // true iff rc QVal was sorted/ranked
 	size_t              nonzTot_;     // # offsets with non-zero size
 	size_t              uniTot_;      // # offsets unique hit
+	size_t              uniTotS_[2];  // # offsets unique hit on each strand
 	size_t              repTot_;      // # offsets repetitive hit
+	size_t              repTotS_[2];  // # offsets repetitive hit on each strand
 	size_t              nonzFw_;      // # offsets into fw read with non-0 size
 	size_t              nonzRc_;      // # offsets into rc read with non-0 size
 	size_t              numRanges_;   // # ranges added
@@ -1473,7 +1491,9 @@ public:
 		bool norc,                  // don't align revcomp read
 		AlignmentCacheIface& cache, // holds some seed hits from previous reads
 		SeedResults& sr,            // holds all the seed hits
-		SeedSearchMetrics& met);    // metrics
+		SeedSearchMetrics& met,     // metrics
+		std::pair<int, int>& instFw,
+		std::pair<int, int>& instRc);
 
 	/**
 	 * Iterate through the seeds that cover the read and initiate a
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_seed2.h bowtie2-mapq/aligner_seed2.h
--- bowtie2-v2.2.9.orig/aligner_seed2.h	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_seed2.h	2016-10-10 23:07:32.000000000 -0400
@@ -2235,6 +2235,8 @@ public:
 		}
 		AlnScore asc(
 			-dr.sink().bestPenalty(),  // numeric score
+			dr.query().length() - edits.size(),
+			(int)edits.size(),         // # edits
 			ns,                        // # Ns
 			ngap);                     // # gaps
 		rs.init(
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_sw.cpp bowtie2-mapq/aligner_sw.cpp
--- bowtie2-v2.2.9.orig/aligner_sw.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_sw.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -431,7 +431,6 @@ int SwAligner::ungappedAlign(
 		// Got a result!  Fill in the rest of the result object.  
 	}
 	// Now fill in the edits
-	res.alres.setScore(AlnScore(score, ns, 0));
 	assert_geq(rowf, rowi);
 	EList<Edit>& ned = res.alres.ned();
 	size_t refns = 0;
@@ -450,6 +449,9 @@ int SwAligner::ungappedAlign(
 			}
 		}
 	}
+	res.alres.setScore(AlnScore(score,
+								(int)(rd.length() - ned.size()),
+								(int)ned.size(), ns, 0));
 	assert(Edit::repOk(ned, rd));
 	bool fw = coord.fw();
 	assert_leq(rowf, len-1);
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_sw_driver.cpp bowtie2-mapq/aligner_sw_driver.cpp
--- bowtie2-v2.2.9.orig/aligner_sw_driver.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_sw_driver.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -1003,7 +1003,9 @@ int SwDriver::extendSeeds(
 					resEe_.alres.reset();
 					const EEHit& h = eehits_[i];
 					assert_leq(h.score, perfectScore);
-					resEe_.alres.setScore(AlnScore(h.score, h.ns(), 0));
+					resEe_.alres.setScore(AlnScore(h.score,
+						(int)(rdlen - h.mms()),
+						h.mms(), h.ns(), 0));
 					resEe_.alres.setShape(
 						refcoord.ref(),  // ref id
 						refcoord.off(),  // 0-based ref offset
@@ -1706,7 +1708,10 @@ int SwDriver::extendSeedsPaired(
 					resEe_.alres.reset();
 					const EEHit& h = eehits_[i];
 					assert_leq(h.score, perfectScore);
-					resEe_.alres.setScore(AlnScore(h.score, h.ns(), 0));
+					resEe_.alres.setScore(AlnScore(
+						h.score,
+						(int)(rdlen - h.mms()),
+						h.mms(), h.ns(), 0));
 					resEe_.alres.setShape(
 						refcoord.ref(),  // ref id
 						refcoord.off(),  // 0-based ref offset
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_swsse_ee_i16.cpp bowtie2-mapq/aligner_swsse_ee_i16.cpp
--- bowtie2-v2.2.9.orig/aligner_swsse_ee_i16.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_swsse_ee_i16.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -1854,6 +1854,8 @@ bool SwAligner::backtraceNucleotidesEnd2
 	off = col;
 	assert_lt(col + (size_t)rfi_, (size_t)rff_);
 	score.gaps_ = gaps;
+	score.edits_ = (int)ned.size();
+	score.basesAligned_ = (int)(rdf_ - rdi_ - trimBeg - trimEnd - score.edits_);
 	res.alres.setScore(score);
 	res.alres.setShape(
 		refidx_,                  // ref id
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_swsse_ee_u8.cpp bowtie2-mapq/aligner_swsse_ee_u8.cpp
--- bowtie2-v2.2.9.orig/aligner_swsse_ee_u8.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_swsse_ee_u8.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -1846,6 +1846,8 @@ bool SwAligner::backtraceNucleotidesEnd2
 	off = col;
 	assert_lt(col + (size_t)rfi_, (size_t)rff_);
 	score.gaps_ = gaps;
+	score.edits_ = (int)ned.size();
+	score.basesAligned_ = (int)(rdf_ - rdi_ - trimBeg - trimEnd - score.edits_);
 	res.alres.setScore(score);
 	res.alres.setShape(
 		refidx_,                  // ref id
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_swsse_loc_i16.cpp bowtie2-mapq/aligner_swsse_loc_i16.cpp
--- bowtie2-v2.2.9.orig/aligner_swsse_loc_i16.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_swsse_loc_i16.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -2219,6 +2219,8 @@ bool SwAligner::backtraceNucleotidesLoca
 	off = col;
 	assert_lt(col + (size_t)rfi_, (size_t)rff_);
 	score.gaps_ = gaps;
+	score.edits_ = (int)ned.size();
+	score.basesAligned_ = (int)(rdf_ - rdi_ - trimBeg - trimEnd - score.edits_);
 	res.alres.setScore(score);
 	res.alres.setShape(
 		refidx_,                  // ref id
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aligner_swsse_loc_u8.cpp bowtie2-mapq/aligner_swsse_loc_u8.cpp
--- bowtie2-v2.2.9.orig/aligner_swsse_loc_u8.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aligner_swsse_loc_u8.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -2213,6 +2213,8 @@ bool SwAligner::backtraceNucleotidesLoca
 	off = col;
 	assert_lt(col + (size_t)rfi_, (size_t)rff_);
 	score.gaps_ = gaps;
+	score.edits_ = (int)ned.size();
+	score.basesAligned_ = (int)(rdf_ - rdi_ - trimBeg - trimEnd - score.edits_);
 	res.alres.setScore(score);
 	res.alres.setShape(
 		refidx_,                  // ref id
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aln_sink.cpp bowtie2-mapq/aln_sink.cpp
--- bowtie2-v2.2.9.orig/aln_sink.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aln_sink.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -715,16 +715,52 @@ void AlnSinkWrap::finishRead(
 				rd1_, rd2_, &rs1_, &rs2_, &rs1u_, &rs2u_,
 				exhaust1, exhaust2, -1, -1);
 			// Sort by score then pick from low to high
-			AlnScore bestUnchosen1, bestUnchosen2, bestUnchosenC;
+			AlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;
+			AlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;
+			AlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;
+			AlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;
+			// TODO: should probably package these variables up so it's not
+			// such a pain to pass them around
 			size_t off = selectByScore(
 				&rs1_, &rs2_,
 				nconcord, select1_,
 				&rs1u_, &rs2u_,
-				bestUnchosen1, bestUnchosen2, bestUnchosenC,
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist,
 				rnd);
-			concordSumm.setUnchosen(bestUnchosen1, bestUnchosen2, bestUnchosenC);
-			assert(concordSumm.best(true).valid());
-			assert(concordSumm.best(false).valid());
+			concordSumm.setBest(
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist);
+			assert(concordSumm.bestScore(true).valid());
+			assert(concordSumm.bestScore(false).valid());
 			assert_lt(off, rs1_.size());
 			const AlnRes *rs1 = &rs1_[off];
 			const AlnRes *rs2 = &rs2_[off];
@@ -848,13 +884,48 @@ void AlnSinkWrap::finishRead(
 				assert(rs1_[i].isFraglenSet() == rs2_[i].isFraglenSet());
 				assert(!rs1_[i].isFraglenSet() || abs(rs1_[i].fragmentLength()) == abs(rs2_[i].fragmentLength()));
 			}
-			AlnScore bestUnchosen1, bestUnchosen2, bestUnchosenC;
+			AlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;
+			AlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;
+			AlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;
+			AlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;
 			ASSERT_ONLY(size_t off =) selectByScore(
 				&rs1_, &rs2_,
 				ndiscord, select1_,
 				&rs1u_, &rs2u_,
-				bestUnchosen1, bestUnchosen2, bestUnchosenC,
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist,
 				rnd);
+			discordSumm.setBest(
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist);
 			assert_eq(0, off);
 			assert(!select1_.empty());
 			g_.reportHits(
@@ -984,9 +1055,46 @@ void AlnSinkWrap::finishRead(
 				rd1_, NULL, NULL, NULL, &rs1u_, NULL,
 				exhaust1, exhaust2, -1, -1);
 			// Sort by score then pick from low to high
-			AlnScore tmp;
+			AlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;
+			AlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;
+			AlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;
+			AlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;
 			size_t off = selectByScore(
-				&rs1u_, NULL, nunpair1, select1_, NULL, NULL, tmp, tmp, tmp, rnd);
+				&rs1u_, NULL, nunpair1, select1_, NULL, NULL,
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist,
+				rnd);
+			summ1.setBest(
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist);
 			repRs1 = &rs1u_[off];
 		} else if(rd1_ != NULL) {
 			// Mate 1 failed to align - don't do anything yet.  First we want
@@ -1000,9 +1108,46 @@ void AlnSinkWrap::finishRead(
 				NULL, rd2_, NULL, NULL, NULL, &rs2u_,
 				exhaust1, exhaust2, -1, -1);
 			// Sort by score then pick from low to high
-			AlnScore tmp;
+			AlnScore bestUScore, bestP1Score, bestP2Score, bestCScore;
+			AlnScore bestUDist, bestP1Dist, bestP2Dist, bestCDist;
+			AlnScore bestUnchosenUScore, bestUnchosenP1Score, bestUnchosenP2Score, bestUnchosenCScore;
+			AlnScore bestUnchosenUDist, bestUnchosenP1Dist, bestUnchosenP2Dist, bestUnchosenCDist;
 			size_t off = selectByScore(
-				&rs2u_, NULL, nunpair2, select2_, NULL, NULL, tmp, tmp, tmp, rnd);
+				&rs2u_, NULL, nunpair2, select2_, NULL, NULL,
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist,
+				rnd);
+			summ2.setBest(
+				bestUScore,
+				bestUDist,
+				bestP1Score,
+				bestP1Dist,
+				bestP2Score,
+				bestP2Dist,
+				bestCScore,
+				bestCDist,
+				bestUnchosenUScore,
+				bestUnchosenUDist,
+				bestUnchosenP1Score,
+				bestUnchosenP1Dist,
+				bestUnchosenP2Score,
+				bestUnchosenP2Dist,
+				bestUnchosenCScore,
+				bestUnchosenCDist);
 			repRs2 = &rs2u_[off];
 		} else if(rd2_ != NULL) {
 			// Mate 2 failed to align - don't do anything yet.  First we want
@@ -1317,9 +1462,22 @@ size_t AlnSinkWrap::selectByScore(
 	EList<size_t>&       select, // prioritized list to put results in
 	const EList<AlnRes>* rs1u,   // alignments to select from (mate 1)
 	const EList<AlnRes>* rs2u,   // alignments to select from (mate 2, or NULL)
-	AlnScore&            bestUnchosen1,
-	AlnScore&            bestUnchosen2,
-	AlnScore&            bestUnchosenC,
+	AlnScore&            bestUScore,
+	AlnScore&            bestUDist,
+	AlnScore&            bestP1Score,
+	AlnScore&            bestP1Dist,
+	AlnScore&            bestP2Score,
+	AlnScore&            bestP2Dist,
+	AlnScore&            bestCScore,
+	AlnScore&            bestCDist,
+	AlnScore&            bestUnchosenUScore,
+	AlnScore&            bestUnchosenUDist,
+	AlnScore&            bestUnchosenP1Score,
+	AlnScore&            bestUnchosenP1Dist,
+	AlnScore&            bestUnchosenP2Score,
+	AlnScore&            bestUnchosenP2Dist,
+	AlnScore&            bestUnchosenCScore,
+	AlnScore&            bestUnchosenCDist,
 	RandomSource&        rnd)
 	const
 {
@@ -1327,11 +1485,26 @@ size_t AlnSinkWrap::selectByScore(
 	assert(repOk());
 	assert_gt(num, 0);
 	assert(rs1 != NULL);
-	
-	if(rs2 != NULL) {
-		assert(rs1u != NULL);
-		assert(rs2u != NULL);
-	}
+	assert(rs2 == NULL || rs1u != NULL);
+	assert(rs2 == NULL || rs2u != NULL);
+
+	bestUScore.invalidate();
+	bestUDist.invalidate();
+	bestUnchosenUScore.invalidate();
+	bestUnchosenUDist.invalidate();
+
+	bestCScore.invalidate();
+	bestP1Score.invalidate();
+	bestP2Score.invalidate();
+	bestCDist.invalidate();
+	bestP1Dist.invalidate();
+	bestP2Dist.invalidate();
+	bestUnchosenCScore.invalidate();
+	bestUnchosenP1Score.invalidate();
+	bestUnchosenP2Score.invalidate();
+	bestUnchosenCDist.invalidate();
+	bestUnchosenP1Dist.invalidate();
+	bestUnchosenP2Dist.invalidate();
 	
 	size_t sz = rs1->size(); // sz = # alignments found
 	assert_leq(num, sz);
@@ -1375,27 +1548,57 @@ size_t AlnSinkWrap::selectByScore(
 		buf.shufflePortion(buf.size() - streak, streak, rnd);
 	}
 	
+	// Copy the permutation into the 'select' list
 	for(size_t i = 0; i < num; i++) { select[i] = buf[i].second; }
 	
+	if(rs2 == NULL) {
+		bestUScore = bestUDist = (*rs1)[select[0]].score();
+	}
+	
+	// For paired-end read, find best alignment score among end
+	// alignments not chosen, for both ends
 	if(rs2 != NULL) {
+		bestCScore = bestCDist = (*rs1)[select[0]].score() + (*rs2)[select[0]].score();
+		bestP1Score = bestP1Dist = (*rs1)[select[0]].score();
+		bestP2Score = bestP2Dist = (*rs2)[select[0]].score();
 		for(size_t i = 0; i < rs1u->size(); i++) {
 			if((*rs1u)[i].refcoord() == (*rs1)[select[0]].refcoord()) {
 				continue;
 			}
-			if((*rs1u)[i].score() > bestUnchosen1) {
-				bestUnchosen1 = (*rs1u)[i].score();
+			if((*rs1u)[i].score() > bestUnchosenP1Score) {
+				bestUnchosenP1Score = (*rs1u)[i].score();
+			}
+			if((*rs1u)[i].score().basesAligned() > bestUnchosenP1Dist.basesAligned()) {
+				bestUnchosenP1Dist = (*rs1u)[i].score();
 			}
 		}
 		for(size_t i = 0; i < rs2u->size(); i++) {
 			if((*rs2u)[i].refcoord() == (*rs2)[select[0]].refcoord()) {
 				continue;
 			}
-			if((*rs2u)[i].score() > bestUnchosen2) {
-				bestUnchosen2 = (*rs2u)[i].score();
+			if((*rs2u)[i].score() > bestUnchosenP2Score) {
+				bestUnchosenP2Score = (*rs2u)[i].score();
+			}
+			if((*rs2u)[i].score().basesAligned() > bestUnchosenP2Dist.basesAligned()) {
+				bestUnchosenP2Dist = (*rs2u)[i].score();
 			}
 		}
 		if(buf.size() > 1) {
-			bestUnchosenC = buf[1].first;
+			bestUnchosenCScore = buf[1].first;
+			for(size_t i = 1; i < buf.size(); i++) {
+				AlnScore dist = (*rs1)[buf[i].second].score() +
+				                (*rs2)[buf[i].second].score();
+				if(dist.basesAligned() > bestUnchosenCDist.basesAligned()) {
+					bestUnchosenCDist = dist;
+				}
+			}
+		}
+	} else if(buf.size() > 1) {
+		bestUnchosenUScore = (*rs1)[buf[1].second].score();
+		for(size_t i = 1; i < buf.size(); i++) {
+			if((*rs1)[buf[1].second].score().basesAligned() > bestUnchosenUDist.basesAligned()) {
+				bestUnchosenUDist = (*rs1)[buf[1].second].score();
+			}
 		}
 	}
 	
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/aln_sink.h bowtie2-mapq/aln_sink.h
--- bowtie2-v2.2.9.orig/aln_sink.h	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/aln_sink.h	2016-10-10 23:07:32.000000000 -0400
@@ -1240,9 +1240,22 @@ protected:
 		EList<size_t>&       select, // prioritized list to put results in
 		const EList<AlnRes>* rs1u,   // alignments to select from (mate 1)
 		const EList<AlnRes>* rs2u,   // alignments to select from (mate 2, or NULL)
-		AlnScore&            bestUnchosen1,
-		AlnScore&            bestUnchosen2,
-		AlnScore&            bestUnchosenC,
+		AlnScore&            bestUScore,
+		AlnScore&            bestUDist,
+		AlnScore&            bestP1Score,
+		AlnScore&            bestP1Dist,
+		AlnScore&            bestP2Score,
+		AlnScore&            bestP2Dist,
+		AlnScore&            bestCScore,
+		AlnScore&            bestCDist,
+		AlnScore&            bestUnchosenUScore,
+		AlnScore&            bestUnchosenUDist,
+		AlnScore&            bestUnchosenP1Score,
+		AlnScore&            bestUnchosenP1Dist,
+		AlnScore&            bestUnchosenP2Score,
+		AlnScore&            bestUnchosenP2Dist,
+		AlnScore&            bestUnchosenCScore,
+		AlnScore&            bestUnchosenCDist,
 		RandomSource&        rnd)
 		const;
 
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/bt2_search.cpp bowtie2-mapq/bt2_search.cpp
--- bowtie2-v2.2.9.orig/bt2_search.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/bt2_search.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -1160,9 +1160,6 @@ static void parseOption(int next_option,
 		case ARG_SAM_PRINT_YI: sam_print_yi = true; break;
 		case ARG_REORDER: reorder = true; break;
 		case ARG_MAPQ_EX: {
-			//sam_print_zp = true;
-			//sam_print_xss = true;
-			//sam_print_yn = true;
 			sam_print_zt = true;
 			break;
 		}
@@ -2860,7 +2857,7 @@ static void multiseedSearchWorker(void *
 	AlnSinkWrap msinkwrap(
 		msink,         // global sink
 		rp,            // reporting parameters
-		*bmapq.get(),  // MAPQ calculator
+		*bmapq,        // MAPQ calculator
 		(size_t)tid);  // thread id
 	
 	// Write dynamic-programming problem descriptions here
@@ -3190,7 +3187,7 @@ static void multiseedSearchWorker(void *
 				// Whether we're done with mate1 / mate2
 				bool done[2] = { !filt[0], !filt[1] };
 				size_t nelt[2] = {0, 0};
-									
+
 					// Find end-to-end exact alignments for each read
 					if(doExactUpFront) {
 						for(size_t matei = 0; matei < (pair ? 2:1); matei++) {
@@ -3370,6 +3367,7 @@ static void multiseedSearchWorker(void *
 							}
 						}
 					}
+
 					// 1-mismatch
 					if(do1mmUpFront && !seedSumm) {
 						for(size_t matei = 0; matei < (pair ? 2:1); matei++) {
@@ -3556,7 +3554,11 @@ static void multiseedSearchWorker(void *
 					nrounds[1] = min<size_t>(nrounds[1], interval[1]);
 					Constraint gc = Constraint::penaltyFuncBased(scoreMin);
 					size_t seedsTried = 0;
+					size_t seedsTriedMS[] = {0, 0, 0, 0};
 					size_t nUniqueSeeds = 0, nRepeatSeeds = 0, seedHitTot = 0;
+					size_t nUniqueSeedsMS[] = {0, 0, 0, 0};
+					size_t nRepeatSeedsMS[] = {0, 0, 0, 0};
+					size_t seedHitTotMS[] = {0, 0, 0, 0};
 					for(size_t roundi = 0; roundi < nSeedRounds; roundi++) {
 						ca.nextRead(); // Clear cache in preparation for new search
 						shs[0].clearSeeds();
@@ -3606,6 +3608,7 @@ static void multiseedSearchWorker(void *
 								continue;
 							}
 							// Instantiate the seeds
+							std::pair<int, int> instFw, instRc;
 							std::pair<int, int> inst = al.instantiateSeeds(
 								*seeds[mate],   // search seeds
 								offset,         // offset to begin extracting
@@ -3616,7 +3619,9 @@ static void multiseedSearchWorker(void *
 								norc[mate],     // don't align revcomp read
 								ca,             // holds some seed hits from previous reads
 								shs[mate],      // holds all the seed hits
-								sdm);           // metrics
+								sdm,            // metrics
+								instFw,
+								instRc);
 							assert(shs[mate].repOk(&ca.current()));
 							if(inst.first + inst.second == 0) {
 								// No seed hits!  Done with this mate.
@@ -3625,6 +3630,8 @@ static void multiseedSearchWorker(void *
 								break;
 							}
 							seedsTried += (inst.first + inst.second);
+							seedsTriedMS[mate * 2 + 0] = instFw.first + instFw.second;
+							seedsTriedMS[mate * 2 + 1] = instRc.first + instRc.second;
 							// Align seeds
 							al.searchAllSeeds(
 								*seeds[mate],     // search seeds
@@ -3648,8 +3655,14 @@ static void multiseedSearchWorker(void *
 						for(size_t mate = 0; mate < 2; mate++) {
 							if(!shs[mate].empty()) {
 								nUniqueSeeds += shs[mate].numUniqueSeeds();
+								nUniqueSeedsMS[mate * 2 + 0] += shs[mate].numUniqueSeedsStrand(true);
+								nUniqueSeedsMS[mate * 2 + 1] += shs[mate].numUniqueSeedsStrand(false);
 								nRepeatSeeds += shs[mate].numRepeatSeeds();
+								nRepeatSeedsMS[mate * 2 + 0] += shs[mate].numRepeatSeedsStrand(true);
+								nRepeatSeedsMS[mate * 2 + 1] += shs[mate].numRepeatSeedsStrand(false);
 								seedHitTot += shs[mate].numElts();
+								seedHitTotMS[mate * 2 + 0] += shs[mate].numEltsFw();
+								seedHitTotMS[mate * 2 + 1] += shs[mate].numEltsRc();
 							}
 						}
 						double uniqFactor[2] = { 0.0f, 0.0f };
@@ -3813,10 +3826,25 @@ static void multiseedSearchWorker(void *
 							}
 						}
 					} // end loop over reseeding rounds
-					if(seedsTried != 0) {
+					if(seedsTried > 0) {
 						prm.seedPctUnique = (float)nUniqueSeeds / seedsTried;
 						prm.seedPctRep = (float)nRepeatSeeds / seedsTried;
 						prm.seedHitAvg = (float)seedHitTot / seedsTried;
+					} else {
+						prm.seedPctUnique = -1.0f;
+						prm.seedPctRep = -1.0f;
+						prm.seedHitAvg = -1.0f;
+					}
+					for(int i = 0; i < 4; i++) {
+						if(seedsTriedMS[i] > 0) {
+							prm.seedPctUniqueMS[i] = (float)nUniqueSeedsMS[i] / seedsTriedMS[i];
+							prm.seedPctRepMS[i] = (float)nRepeatSeedsMS[i] / seedsTriedMS[i];
+							prm.seedHitAvgMS[i] = (float)seedHitTotMS[i] / seedsTriedMS[i];
+						} else {
+							prm.seedPctUniqueMS[i] = -1.0f;
+							prm.seedPctRepMS[i] = -1.0f;
+							prm.seedHitAvgMS[i] = -1.0f;
+						}
 					}
 					size_t totnucs = 0;
 					for(size_t mate = 0; mate < (pair ? 2:1); mate++) {
@@ -3828,7 +3856,10 @@ static void multiseedSearchWorker(void *
 							totnucs += len;
 						}
 					}
-					prm.seedsPerNuc = (float)seedsTried / totnucs;
+					prm.seedsPerNuc = totnucs > 0 ? ((float)seedsTried / totnucs) : -1;
+					for(int i = 0; i < 4; i++) {
+						prm.seedsPerNucMS[i] = totnucs > 0 ? ((float)seedsTriedMS[i] / totnucs) : -1;
+					}
 					for(size_t i = 0; i < 2; i++) {
 						assert_leq(prm.nExIters, mxIter[i]);
 						assert_leq(prm.nExDps,   mxDp[i]);
@@ -3934,7 +3965,7 @@ static void multiseedSearchWorker_2p5(vo
 	AlnSinkWrap msinkwrap(
 		msink,         // global sink
 		rp,            // reporting parameters
-		*bmapq.get(),  // MAPQ calculator
+		*bmapq,        // MAPQ calculator
 		(size_t)tid);  // thread id
 
 	OuterLoopMetrics olm;
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/read.h bowtie2-mapq/read.h
--- bowtie2-v2.2.9.orig/read.h	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/read.h	2016-10-10 23:07:32.000000000 -0400
@@ -518,10 +518,14 @@ struct PerReadMetrics {
 	TAlScore bestLtMinscMate1; // best invalid score observed for mate 1
 	TAlScore bestLtMinscMate2; // best invalid score observed for mate 2
 	
-	float seedPctUnique; // % of read covered by unique seed hits
-	float seedPctRep;    // % of read covered by repetitive seed hits
-	float seedHitAvg;    // avg # seed hits per hitting seed
-	float seedsPerNuc;   // # seeds tried / # alignable nucleotides
+	float seedPctUnique;      // % of read covered by unique seed hits
+	float seedPctUniqueMS[4]; // % of read covered by unique seed hits by mate and strand
+	float seedPctRep;         // % of read covered by repetitive seed hits
+	float seedPctRepMS[4];    // % of read covered by repetitive seed hits by mate and strand
+	float seedHitAvg;         // avg # seed hits per hitting seed
+	float seedHitAvgMS[4];    // avg # seed hits per hitting seed by mate and strand
+	float seedsPerNuc;        // # seeds tried / # alignable nucleotides
+	float seedsPerNucMS[4];   // # seeds tried / # alignable nucleotides by mate and strand
 	
 	// For collecting information to go into an FM string
 	bool doFmString;
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/sam.cpp bowtie2-mapq/sam.cpp
--- bowtie2-v2.2.9.orig/sam.cpp	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/sam.cpp	2016-10-10 23:07:32.000000000 -0400
@@ -134,23 +134,7 @@ void SamConfig::printAlignedOptFlags(
 	const
 {
 	char buf[1024];
-	assert(summ.best(rd.mate < 2).valid());
-	if(print_zt_) {
-		// ZT:Z: Extra features for MAPQ estimation
-		WRITE_SEP();
-		o.append("ZT:Z:");
-		itoa10<TAlScore>((int)(prm.seedsPerNuc * 1000), buf);
-		o.append(buf);
-		o.append(",");
-		itoa10<TAlScore>((int)(prm.seedPctUnique * 1000), buf);
-		o.append(buf);
-		o.append(",");
-		itoa10<TAlScore>((int)(prm.seedPctRep * 1000), buf);
-		o.append(buf);
-		o.append(",");
-		itoa10<TAlScore>((int)(prm.seedHitAvg + 0.5), buf);
-		o.append(buf);
-	}
+	assert(summ.bestScore(rd.mate < 2).valid());
 	if(print_as_) {
 		// AS:i: Alignment score generated by aligner
 		itoa10<TAlScore>(res.score().score(), buf);
@@ -161,10 +145,10 @@ void SamConfig::printAlignedOptFlags(
 	if(print_xs_) {
 		// XS:i: Suboptimal alignment score
 		AlnScore sco;
-		if(flags.alignedConcordant()) {
-			sco = summ.bestUnchosen(rd.mate < 2);
+		if(flags.partOfPair()) {
+			sco = summ.bestUnchosenPScore(rd.mate < 2);
 		} else {
-			sco = summ.secbest(rd.mate < 2);
+			sco = summ.bestUnchosenUScore();
 		}
 		if(sco.valid()) {
 			itoa10<TAlScore>(sco.score(), buf);
@@ -349,24 +333,24 @@ void SamConfig::printAlignedOptFlags(
 	}
 	if(flags.partOfPair() && print_zp_) {
 		// ZP:i: Score of best concordant paired-end alignment
-		if(summ.bestPaired().valid()) {
+		if(summ.bestCScore().valid()) {
 			WRITE_SEP();
 			o.append("ZP:i:");
-			itoa10<TAlScore>(summ.bestPaired().score(), buf);
+			itoa10<TAlScore>(summ.bestCScore().score(), buf);
 			o.append(buf);
 		}
 		// Zp:i: Score of second-best concordant paired-end alignment
-		if(summ.secbestPaired().valid()) {
+		if(summ.bestUnchosenCScore().valid()) {
 			WRITE_SEP();
 			o.append("Zp:i:");
-			itoa10<TAlScore>(summ.secbestPaired().score(), buf);
+			itoa10<TAlScore>(summ.bestUnchosenCScore().score(), buf);
 			o.append(buf);
 		}
 	}
 	if(print_zu_) {
 		// ZU:i: Score of best unpaired alignment
-		AlnScore best    = (rd.mate <= 1 ? summ.best1()    : summ.best2());
-		AlnScore secbest = (rd.mate <= 1 ? summ.secbest1() : summ.secbest2());
+		AlnScore best    = summ.bestScore(rd.mate <= 1);
+		AlnScore secbest = summ.bestUnchosenPScore(rd.mate <= 1);
 		WRITE_SEP();
 		o.append("ZU:i:");
 		if(best.valid()) {
@@ -535,6 +519,152 @@ void SamConfig::printAlignedOptFlags(
 		o.append("\n");
 		printOptFieldNewlineEscapedZ(o, rd.readOrigBuf);
 	}
+	if(print_zt_) {
+		// ZT:Z: Extra features for MAPQ estimation
+		WRITE_SEP();
+		const bool paired = flags.partOfPair();
+		const TAlScore MN = std::numeric_limits<TAlScore>::min();
+		TAlScore secondBest[2] = {MN, MN};
+		TAlScore thirdBest[2] = {MN, MN};
+		const int ED_MAX = std::numeric_limits<int>::max();
+		AlnScore best[2] = {res.score(), res.oscore()};
+		TAlScore diffEd[2] = {ED_MAX, ED_MAX};
+		for (int self = 0; self < (paired ? 2 : 1); self++) {
+			// Second-best
+			AlnScore sco;
+			bool mate1 = rd.mate < 2; // first iteration: self
+			if(self > 0) mate1 = !mate1; // second iteration: opposite
+			if(flags.partOfPair()) {
+				sco = summ.bestUnchosenPScore(mate1);
+			} else {
+				sco = summ.bestUnchosenUScore();
+			}
+			if(sco.valid()) {
+				secondBest[self] = sco.score();
+			}
+
+			// Third-best
+			thirdBest[self] = mate1 ? prm.bestLtMinscMate1 : prm.bestLtMinscMate2;
+			
+			if(flags.partOfPair()) {
+				if(summ.bestUnchosenPDist(mate1).valid()) {
+					diffEd[self] = best[self].basesAligned() - summ.bestUnchosenPDist(mate1).basesAligned();
+				}
+			} else {
+				if(summ.bestUnchosenUDist().valid()) {
+					diffEd[self] = best[self].basesAligned() - summ.bestUnchosenUDist().basesAligned();
+				}
+			}
+		}
+		TAlScore diff[2] = {MN, MN};
+		for(int self = 0; self < 2; self++) {
+			const TAlScore mx = max(secondBest[self], thirdBest[self]);
+			if(best[self].score() > MN && mx > MN) {
+				diff[self] = best[self].score() - mx;
+			}
+		}
+		TAlScore best_conc = MN, diff_conc = MN;
+		int diffEd_conc = ED_MAX;
+		if(paired && summ.bestCScore().valid()) {
+			best_conc = summ.bestCScore().score();
+			if(summ.bestUnchosenCScore().valid()) {
+				diff_conc = best_conc - summ.bestUnchosenCScore().score();
+			}
+			if(summ.bestUnchosenCDist().valid()) {
+				diffEd_conc = summ.bestCDist().basesAligned() - summ.bestUnchosenCDist().basesAligned();
+			}
+		}
+		o.append("ZT:Z:");
+		// AS:i for current mate
+		itoa10<TAlScore>((int)best[0].score(), buf);
+		o.append(buf);
+		o.append(",");
+		// diff for current mate
+		if(diff[0] > MN) {
+			itoa10<TAlScore>((int)diff[0], buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		o.append(",");
+		// edit distance diff for current mate
+		if(diffEd[0] != ED_MAX) {
+			itoa10<TAlScore>((int)diffEd[0], buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		o.append(",");
+		// AS:i for other mate
+		if(best[1].score() > MN) {
+			itoa10<TAlScore>((int)best[1].score(), buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		o.append(",");
+		// diff for other mate
+		if(diff[1] > MN) {
+			itoa10<TAlScore>((int)diff[1], buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		o.append(",");
+		// Sum of AS:i for aligned pairs
+		if(best_conc > MN) {
+			itoa10<TAlScore>((int)best_conc, buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		o.append(",");
+		// Diff for aligned pairs
+		if(diff_conc > MN) {
+			itoa10<TAlScore>((int)diff_conc, buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		o.append(",");
+		// Edit distance diff for aligned pairs
+		if(diffEd_conc != ED_MAX) {
+			itoa10<TAlScore>((int)diffEd_conc, buf);
+			o.append(buf);
+		} else {
+			o.append("NA");
+		}
+		// Flags related to seed hits, specific to this mate but not to the
+		// strand aligned to
+		int mate = (rd.mate < 2 ? 0 : 1);
+		o.append(",");
+		itoa10<TAlScore>((int)((prm.seedsPerNucMS[2 * mate] + prm.seedsPerNucMS[2 * mate + 1]) * 1000), buf);
+		o.append(buf);
+		o.append(",");
+		itoa10<TAlScore>((int)((prm.seedPctUniqueMS[2 * mate] + prm.seedPctUniqueMS[2 * mate + 1]) * 1000), buf);
+		o.append(buf);
+		o.append(",");
+		itoa10<TAlScore>((int)((prm.seedPctRepMS[2 * mate] + prm.seedPctRepMS[2 * mate + 1]) * 1000), buf);
+		o.append(buf);
+		o.append(",");
+		itoa10<TAlScore>((int)((prm.seedHitAvgMS[2 * mate] + prm.seedHitAvgMS[2 * mate + 1]) + 0.5f), buf);
+		o.append(buf);
+		// Flags related to seed hits again, but specific both to this mate and
+		// to the strand aligned to
+		int fw = res.fw() ? 0 : 1;
+		o.append(",");
+		itoa10<TAlScore>((int)(prm.seedsPerNucMS[2 * mate + fw] * 1000), buf);
+		o.append(buf);
+		o.append(",");
+		itoa10<TAlScore>((int)(prm.seedPctUniqueMS[2 * mate + fw] * 1000), buf);
+		o.append(buf);
+		o.append(",");
+		itoa10<TAlScore>((int)(prm.seedPctRepMS[2 * mate + fw] * 1000), buf);
+		o.append(buf);
+		o.append(",");
+		itoa10<TAlScore>((int)(prm.seedHitAvgMS[2 * mate + fw] + 0.5f), buf);
+		o.append(buf);
+	}
 }
 
 /**
diff -rupN -x Xcode -x .git bowtie2-v2.2.9.orig/unique.h bowtie2-mapq/unique.h
--- bowtie2-v2.2.9.orig/unique.h	2016-10-11 08:29:28.000000000 -0400
+++ bowtie2-mapq/unique.h	2016-10-10 23:07:32.000000000 -0400
@@ -61,7 +61,7 @@ public:
 		char *inps)
 	{
 		assert(!s.empty());
-		return !VALID_AL_SCORE(s.secbest(mate1));
+		return !VALID_AL_SCORE(s.bestUnchosenScore(mate1));
 	}
 };
 
@@ -120,20 +120,20 @@ public:
 		if(s.paired()) {
 			return pair_nosec_perf;
 		} else {
-			bool hasSecbest = VALID_AL_SCORE(s.secbest(mate1));
+			bool hasSecbest = VALID_AL_SCORE(s.bestUnchosenScore(mate1));
 			if(!flags.canMax() && !s.exhausted(mate1) && !hasSecbest) {
 				return 255;
 			}
 			TAlScore scMax = (TAlScore)sc_.perfectScore(rdlen);
 			TAlScore scMin = scoreMin_.f<TAlScore>((float)rdlen);
 			assert_geq(scMax, scMin);
-			TAlScore best  = scMax - s.best(mate1).score(); // best score (lower=better)
+			TAlScore best  = scMax - s.bestScore(mate1).score(); // best score (lower=better)
 			size_t best_bin = (size_t)((double)best * (10.0 / (double)(scMax - scMin)) + 0.5);
 			assert_geq(best_bin, 0);
 			assert_lt(best_bin, 11);
 			if(hasSecbest) {
-				assert_geq(s.best(mate1).score(), s.secbest(mate1).score());
-				size_t diff = s.best(mate1).score() - s.secbest(mate1).score();
+				assert_geq(s.bestScore(mate1).score(), s.bestUnchosenScore(mate1).score());
+				size_t diff = s.bestScore(mate1).score() - s.bestUnchosenScore(mate1).score();
 				size_t diff_bin = (size_t)((double)diff * (10.0 / (double)(scMax - scMin)) + 0.5);
 				assert_geq(diff_bin, 0);
 				assert_lt(diff_bin, 11);
@@ -194,8 +194,8 @@ public:
 	{
 		// Did the read have a second-best alignment?
 		bool hasSecbest = s.paired() ?
-			VALID_AL_SCORE(s.secbestPaired()) :
-			VALID_AL_SCORE(s.secbest(mate1));
+			VALID_AL_SCORE(s.bestUnchosenCScore()) :
+			VALID_AL_SCORE(s.bestUnchosenScore(mate1));
 		// This corresponds to a scenario where we found one and only one
 		// alignment but didn't really look for a second one
 		if(!flags.canMax() && !s.exhausted(mate1) && !hasSecbest) {
@@ -215,7 +215,7 @@ public:
 		TAlScore diff = (scPer - scMin);  // scores can vary by up to this much
 		TMapq ret = 0;
 		TAlScore best = s.paired() ?
-			s.bestPaired().score() : s.best(mate1).score();
+			s.bestCScore().score() : s.bestScore(mate1).score();
 		// best score but normalized so that 0 = worst valid score
 		TAlScore bestOver = best - scMin;
 		if(sc_.monotone) {
@@ -230,7 +230,7 @@ public:
 				else                                     ret = 0;
 			} else {
 				secbest = s.paired() ?
-					s.secbestPaired().score() : s.secbest(mate1).score();
+					s.bestUnchosenCScore().score() : s.bestUnchosenScore(mate1).score();
 				TAlScore bestdiff = abs(abs(static_cast<long>(best))-abs(static_cast<long>(secbest)));
 				if(bestdiff >= diff * (double)0.9f) {
 					if(bestOver == diff) {
@@ -340,7 +340,7 @@ public:
 				else                                     ret = 22;
 			} else {
 				secbest = s.paired() ?
-					s.secbestPaired().score() : s.secbest(mate1).score();
+					s.bestUnchosenCScore().score() : s.bestUnchosenScore(mate1).score();
 				TAlScore bestdiff = abs(abs(static_cast<long>(best))-abs(static_cast<long>(secbest)));
 				if     (bestdiff >= diff * (double)0.9f) ret = 40;
 				else if(bestdiff >= diff * (double)0.8f) ret = 39;
@@ -437,7 +437,7 @@ public:
 		char *inps)     // put string representation of inputs here
 		const
 	{
-		bool hasSecbest = VALID_AL_SCORE(s.secbest(mate1));
+		bool hasSecbest = VALID_AL_SCORE(s.bestUnchosenScore(mate1));
 		if(!flags.canMax() && !s.exhausted(mate1) && !hasSecbest) {
 			return 255;
 		}
@@ -448,7 +448,7 @@ public:
 		float sixth_2 = (float)(scPer - diff * (double)0.1666f * 2); 
 		float sixth_3 = (float)(scPer - diff * (double)0.1666f * 3);
 		TMapq ret = 0;
-		TAlScore best = s.best(mate1).score();
+		TAlScore best = s.bestScore(mate1).score();
 		if(!hasSecbest) {
 			// Top third?
 			if(best >= sixth_2) {
@@ -463,7 +463,7 @@ public:
 				ret = 10;
 			}
 		} else {
-			secbest = s.secbest(mate1).score();
+			secbest = s.bestUnchosenScore(mate1).score();
 			TAlScore bestdiff = abs(abs(static_cast<long>(best))-abs(static_cast<long>(secbest)));
 			if(bestdiff >= diff * 0.1666 * 5) {
 				ret = 6;
